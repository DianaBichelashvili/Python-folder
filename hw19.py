
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class linkedlist:
    def __init__(self):
        self.head = None

#პრინტის მეთოდი , რომ დავინახოთ რა მონაცემები არის შეყვანილი ლინკდლისტი
#ორი მეთოდი იწერება ერთ დროულად
#ჯერ არის append და შემდეგ გამოჩენის მეთოდი print 
#append - ამატებს ლისტის ბოლო ელემენტს
#append ის დროს ვამატებთ ახალ მონაცემს, რომელიც ატრიბუტად გადაეცემა აფენდს

def append(self, new_data):
      new_node = Node(new_data)# აფენდის განხორციელებისას ვქმნით ახალ ნოუდს.
      if self.head is None: #აქ მოწმდება სად ჩაჯდა ახალი ნოუდი, თუ ჰედი არ გვაქვს
        self.head = new_node   #ჰედი უნდა გახდეს ახალი ნოუდი
        return 
      
      #ქვემოთ უკვე ძიებას იწყებს ბოლო ელემენტიდან/
      # თუ გვაქვს ჰედი,  მაშინ უნდა მოვიძიოთ ბოლო ელემენტი
      #ბოლო ელემენტი არის ჰედი ამასთანავე და ნექსთიც ნანი იქნება რადგან ამავე დროს ბოლოა
      # თუ ბოლო ელემენტს გააჩნია ნექსთი მაშინ ვანიჭებთ ნიუ მოუდს და ვაილის მეშვეობით ვამოწმებთ სანამ მაქვს ნექსთი გააჩნია . შესაბამსისად ბოლო ელემნტზე არ არის მისული
      
      last_node = self.head

      while(last_node.next):
          last_node = last_node.next
      
      last_node.next = new_node
            
            #აქ აღწერილია ბეჭდვის მეთოდი, 

      def print(self):
         current_node = self.head
    
         while current_node is not None:
            print(current_node.data, end='') #ერთ ხაზზე რომ დაიბეჭდოს ყველა ელემენტი
            current_node = current_node.next #აქ ქერენთ ნოუდი არის ჰედი. მაგრამ დაბეჭდვის შემდეგ გახდება ნექსთი სანამ არ მივა ბოლო ელემენტზე
                                             #მანამ სანამ ვაილი არ გახდება ნანი





